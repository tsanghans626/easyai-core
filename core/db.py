import asyncio
import configparser
import re
from contextlib import asynccontextmanager
from pathlib import Path
from typing import AsyncGenerator

import sqlalchemy as sa
from litestar import Litestar
from alembic import command, config
from alembic.util.exc import AutogenerateDiffsDetected
from litestar.plugins.sqlalchemy import SQLAlchemyAsyncConfig
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from core.config import settings
from core.log import logger
from core.utils import get_s_timestamp
from core.exc import ConfigException


class Base(DeclarativeBase):
    id: Mapped[int] = mapped_column(primary_key=True, comment="自增ID")
    created_at: Mapped[int] = mapped_column(default=get_s_timestamp, comment="创建时间")
    updated_at: Mapped[int] = mapped_column(
        default=get_s_timestamp, onupdate=get_s_timestamp, comment="更新时间"
    )


db_config = SQLAlchemyAsyncConfig(
    connection_string=settings.db.sqlalchemy_url,
    metadata=Base.metadata,
    create_all=True,
)


async def _check_database_exist():
    """检查数据库是否创建"""
    _engine = create_async_engine(
        settings.db.sqlalchemy_url_without_schema,
        pool_size=settings.db.pool_size,
        max_overflow=settings.db.max_overflow,
        echo=settings.db.echo,
        pool_pre_ping=settings.db.pool_pre_ping,
        pool_recycle=settings.db.pool_recycle,
    )

    async with _engine.connect() as conn:
        res = await conn.execute(sa.text("SHOW DATABASES"))
        dbs = res.scalars().all()
        if settings.db.schema not in dbs:
            logger.info(f"检测到未创建数据库{settings.db.schema}，3秒后将自动创建")
            await asyncio.sleep(3)
            # FIXME: 总是新建'db_name'多了两个单引号
            await conn.execute(
                sa.text(
                    "CREATE DATABASE `:db_name`"
                    " DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;"
                ),
                {"db_name": settings.db.schema},
            )
            logger.info(f"已成功创建数据库{settings.db.schema}")


def _update_alembic_ini():
    # 修改alembic.ini配置文件
    parser = configparser.ConfigParser()
    parser.read(settings.db.alembic_cfg_filename)
    parser.set("alembic", "script_location", settings.db.alembic_script_location)
    sqlalchemy_url = settings.db.sqlalchemy_url.render_as_string(hide_password=False)
    parser.set("alembic", "sqlalchemy.url", sqlalchemy_url)
    with open(settings.db.alembic_cfg_filename, "w") as f:
        parser.write(f)


def _update_alembic_env():
    """更新 alembic env.py 中的 metadata 配置"""
    env_path = f"{settings.db.alembic_script_location}/env.py"

    # 读取文件内容
    with open(env_path, "r") as file:
        content = file.read()

    # 定义要替换的模式
    pattern = r"target_metadata = None"

    # 新的配置内容
    replacement = (
        "from fastapi_share_core.db import Base\ntarget_metadata = Base.metadata"
    )

    # 执行替换
    new_content = re.sub(pattern, replacement, content)

    # 写回文件
    with open(env_path, "w") as file:
        file.write(new_content)


async def _check_alembic_init():
    """检查alembic是否初始化"""
    # 检查alembic是否初始化
    if not (
        Path(settings.db.alembic_script_location).is_dir()
        or Path(settings.db.alembic_cfg_filename).is_file()
    ):
        logger.info("检测到alembic还未初始化，3秒后将自动初始化")
        await asyncio.sleep(3)
        alembic_cfg = config.Config(settings.db.alembic_cfg_filename)

        command.init(alembic_cfg, settings.db.alembic_script_location, "async")

        _update_alembic_ini()
        _update_alembic_env()
        logger.info("alembic 已成功初始化")


async def _sync_db_and_orm():
    logger.info("正在检测数据表与ORM的一致性")
    alembic_cfg = config.Config(settings.db.alembic_cfg_filename)
    command.upgrade(alembic_cfg, "head")

    try:
        command.check(alembic_cfg)
    except AutogenerateDiffsDetected:
        logger.info("数据表和ORM存在差异，3秒后将自动生成迁移文件")
        await asyncio.sleep(3)
        command.revision(alembic_cfg, autogenerate=True)

    command.upgrade(alembic_cfg, "head")
    logger.info("迁移完成，数据表与ORM已保持一致")


async def _drop_alembic_version():
    _engine = create_async_engine(
        settings.db.sqlalchemy_url,
        pool_size=settings.db.pool_size,
        max_overflow=settings.db.max_overflow,
        echo=settings.db.echo,
        pool_pre_ping=settings.db.pool_pre_ping,
        pool_recycle=settings.db.pool_recycle,
    )
    async with _engine.connect() as conn:
        await conn.execute(sa.text("DROP TABLE IF EXISTS alembic_version;"))


async def create_all_tables():
    _engine = create_async_engine(
        settings.db.sqlalchemy_url,
        pool_size=settings.db.pool_size,
        max_overflow=settings.db.max_overflow,
        echo=settings.db.echo,
        pool_pre_ping=settings.db.pool_pre_ping,
        pool_recycle=settings.db.pool_recycle,
    )
    async with _engine.connect() as conn:
        await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)


@asynccontextmanager
async def check_db(app: Litestar) -> AsyncGenerator[None, None]:
    if any(
        [
            settings.db.host is None,
            settings.db.port is None,
            settings.db.user is None,
            settings.db.pwd is None,
            settings.db.schema is None,
        ]
    ):
        raise ConfigException("请检查数据库配置")

    # await _check_database_exist()
    await _check_alembic_init()
    if settings.env == "production":
        await _sync_db_and_orm()
    elif settings.env == "test":
        await _drop_alembic_version()
        await _sync_db_and_orm()
    else:
        await create_all_tables()
    yield
